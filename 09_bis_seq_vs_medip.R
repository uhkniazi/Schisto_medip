# File: 09_bis_seq_vs_medip.R
# Auth: umar.niazi@kcl.ac.uk
# DESC: uses the data generated by frank lyko and analyzed by bismark - and compared with medip data
# Date: 09/09/2016


# source header file
source('00_header.R')
library(Biostrings)

##################################################################
######## data loading and formatting
# connect to mysql database to find file locations
library('RMySQL')

##### connect to mysql database to get samples
db = dbConnect(MySQL(), user='rstudio', password='12345', dbname='Projects', host='127.0.0.1')
dbListTables(db)
dbListFields(db, 'MetaFile')
# another way to get the query, preferred
dfSample = dbGetQuery(db, "select * from MetaFile where idData=3;")

# Choose R object file with pooled Medip peaks, look in Objects/ directoy
f = paste0(dfSample$location[2], dfSample$name[2])
oGRpooled = f_LoadObject(f)
oGRpooled = oGRpooled$m
oGRpooled = oGRpooled[seqnames(oGRpooled) %in% gcvChromosomes]
# 
# oGR.bis = read.csv(file.choose(), header=F, sep='\t')
# oGR.bis = oGR.bis[-1,]
# oGR.bis = GRanges(oGR.bis$V1, IRanges(oGR.bis$V2, oGR.bis$V3), mcols=DataFrame(proportion=oGR.bis$V4))

## load from here for next use or load the unstranded object
oGR.bis = f_LoadObject(file.choose())
########## remove Cs with 0.1 or less proportions
f = which(oGR.bis$mcols.proportion >= 0.1)
## create a histogram of the data based on proportions similar to lyko paper figure 1
x = oGR.bis$mcols.proportion[f]
s = seq(0.1, to = 1, by = 0.1)
hist(x, breaks=s, ylab='Fraction', xlab='Proportion', main='Methylation proportions of 5mCs', xaxt='n', prob=T, ylim=c(0, 6))
axis(1, at = s)

f = which(oGR.bis$mcols.proportion >= 0.9)
oGR.bis = oGR.bis[f]
gc()
## assign strands to the base positions
## use the biostrings object for genome version 5.2 created earlier
seq = f_LoadObject(file.choose())
# rename all the W chromosome to ZW
r1 = oGR.bis[seqnames(oGR.bis) %in% gcvChromosomes]
r2 = oGR.bis[seqnames(oGR.bis) == 'Schisto_mansoni.Chr_W']
r1 = GRanges(as.character(seqnames(r1)), IRanges(start(r1), end(r1)), strand(r1), DataFrame(mcols(r1)))
r2 = GRanges('Schisto_mansoni.Chr_ZW', IRanges(start(r2), end(r2)), strand(r2), DataFrame(mcols(r2)))
oGR.bis = c(r1, r2)
s = as.character(unique(seqnames(oGR.bis)))
for (i in 1:length(s)){
  # check base content for the chromosome
  base = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis[seqnames(oGR.bis) == s[i]])
  print(s[i])
  print(colSums(alphabetFrequency(base)))
  # remove bases with A or T as those are not the right positions
  f = base == 'C'
  st = rep(NA, length(f))
  st[f] = '+'
  st[!f] = '-'
  f2 = which(seqnames(oGR.bis) == s[i])
  strand(oGR.bis[f2]) = st
}
rm(list = c('base', 'f', 'f2', 'r1', 'r2', 'st'))
gc()

n = make.names(paste('oGRbis lyko stranded rds'))
n2 = paste0('Objects/', n)
save(oGR.bis, file=n2)

# make a database entry after saving the bs-seq object
dbListFields(db, 'MetaFile')
df = data.frame(idData=3, name=n, type='rds', location='Objects/', comment='lykos bs seq data at 0.9 proportion cutoff and stranded')
dbWriteTable(db, name = 'MetaFile', value=df, append=T, row.names=F)
dbDisconnect(db)
############# look at overlaps of medip and bs-seq
### how many overlaps between bs-seq data and medip peaks in males
dfOverlaps = data.frame(table(overlapsAny(oGRpooled, oGR.bis)))
dfOverlaps.nostrand = data.frame(table(overlapsAny(oGRpooled, oGR.bis, ignore.strand=T)))

# do it the other way
dfOverlaps.bs = data.frame(table(overlapsAny(oGR.bis, oGRpooled)))
dfOverlaps.bs.nostrand = data.frame(table(overlapsAny(oGR.bis, oGRpooled, ignore.strand=T)))



##################################################################################
###### dinucleotide frequencies
# seq is a DNAStringSet object created sometime back from genome version 5.2
oGR.bis.w = resize(oGR.bis, 2, fix = 'start')
s = as.character(unique(seqnames(oGR.bis.w)))
seq.bs = vector()
for (i in 1:length(s)){
  # check base content for the chromosome
  seq.bs.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '+' & seqnames(oGR.bis.w) == s[i]])
  seq.bs.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '-' & seqnames(oGR.bis.w) == s[i]])
  print(s[i])
  seq.bs.minus = reverseComplement(seq.bs.minus)
  seq.bs = c(seq.bs, c(seq.bs.plus, seq.bs.minus))
}

seq.bs = unlist(DNAStringSetList(seq.bs))

mFreq.bs = matrix(NA, 1000, 4)

# resample from the object to fill the matrix
nBoot = 1000
for( i in 1:nBoot){
  # take sample of 1000 positions
  s = sample(1:length(seq.bs), size = 1000, replace = F)
  s = seq.bs[s]
  m = dinucleotideFrequency(s, as.prob=T)[,c('CA', 'CC', 'CG', 'CT')]
  mFreq.bs[i,] = colMeans(m)
}
colnames(mFreq.bs) = c('CA', 'CC', 'CG', 'CT')

## calculate for medip data
## choose only peaks with a width upto the 0.95 quantile
c = quantile(width(oGRpooled), prob=0.95)
f = which(width(oGRpooled) <= c)
oGRpooled.sub = oGRpooled[f]
# get the sequence for plus, * and minus sides
s = as.character(unique(seqnames(oGRpooled.sub)))
seq.med = vector()

for (i in 1:length(s)){
  # check base content for the chromosome
  seq.med.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) == '+' & seqnames(oGRpooled.sub) == s[i]])
  seq.med.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) == '-' & seqnames(oGRpooled.sub) == s[i]])
  print(s[i])
  seq.med.minus = reverseComplement(seq.med.minus)
  seq.med = c(seq.med, c(seq.med.plus, seq.med.minus))
}

seq.med = unlist(DNAStringSetList(seq.med))

mFreq.med = matrix(NA, 1000, 4)

# resample from the object to fill the matrix
nBoot = 1000
for( i in 1:nBoot){
  # take sample of 1000 positions
  s = sample(1:length(seq.med), size = 1000, replace = F)
  s = seq.med[s]
  m = dinucleotideFrequency(s, as.prob=T)[,c('CA', 'CC', 'CG', 'CT')]
  mFreq.med[i,] = colMeans(m)
}
colnames(mFreq.med) = c('CA', 'CC', 'CG', 'CT')

# take a random sample from chromosome 1 of size 500 width each
s = seq[gcvChromosomes[2]]
r = f_bin_vector(1, end = 65476681, bins = 130953)
# ranges of 500 size
oGRran = GRanges(gcvChromosomes[2], IRanges(r$start, r$end))
seq.ran = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRran)

mFreq.ran = matrix(NA, 1000, 4)

# resample from the object to fill the matrix
nBoot = 1000
for( i in 1:nBoot){
  # take sample of 1000 positions
  s = sample(1:length(seq.ran), size = 1000, replace = F)
  s = seq.ran[s]
  m = dinucleotideFrequency(s, as.prob=T)[,c('CA', 'CC', 'CG', 'CT')]
  mFreq.ran[i,] = colMeans(m)
}
colnames(mFreq.ran) = c('CA', 'CC', 'CG', 'CT')

# Using the formula for alpha and beta for the beta distribution (see Gelman 2008) 
# the mean and the variance are used to solve for alpha and beta. This would normally
# be used if we have a vector of proportions (say an exchangable distribution) and we
# want to calculate a beta distribution parameters for that.
getalphabeta = function(m, v){
  al.be = (m * (1-m) / v) - 1
  al = al.be * m
  be = al.be * (1-m)
  return(list(alpha=al, beta=be))
}
# get averages for each frequency
lFreq.bs = apply(mFreq.bs, 2, function(x) getalphabeta(mean(x), var(x)))
lFreq.med = apply(mFreq.med, 2, function(x) getalphabeta(mean(x), var(x)))
lFreq.ran = apply(mFreq.ran, 2, function(x) getalphabeta(mean(x), var(x)))

# # scale these to the same level
# iFreq.bs = round(iFreq.bs * 1000, 0)
# iFreq.med = round(iFreq.med * 1000, 0)
# iFreq.ran = round(iFreq.ran * 1000, 0)

## plotting functions
if(!require(LearnBayes)) stop('R Package LearnBayes required')
# get posterior theta from posterior dirichlet
getPosterior = function(param, n=1000){
  alpha = param$alpha
  beta = param$beta
  p = rbeta(n, alpha, beta)
  return(p)
}

# bar plot with error bars
plot.bar = function(mDat, title='Abundance', ...){
  # get the median to plot
  p.old = par(mar=c(6,3,2,2)+0.1)
  mBar = apply(mDat, 2, mean)
  names(mBar) = colnames(mDat)
  yl = max(apply(mDat, 2, quantile, 0.98))
  l = barplot(mBar, beside=T, xaxt='n', ylim=c(0, yl), main=title, ...)
  axis(side = 1, l[,1], labels=F)
  text(l[,1], y=par()$usr[3]-0.1*(par()$usr[4]-par()$usr[3]),
       labels=names(mBar), srt=45, adj=1, xpd=TRUE, cex=0.6)
  ## draw error bars
  f_barplot_errorbars = function(x.loc, y.loc){
    segments(x.loc, y.loc[1], x.loc, y.loc[2])
    segments(x.loc-0.1, y.loc[1], x.loc+0.1, y.loc[1])
    segments(x.loc-0.1, y.loc[2], x.loc+0.1, y.loc[2])
  }
  sapply(seq_along(1:ncol(mDat)), function(x) f_barplot_errorbars(l[x,1], quantile(mDat[,x], c(0.025, 0.975))))
  par(p.old)
}

plot.bar(sapply(lFreq.bs, getPosterior), title = 'BS')
plot.bar(sapply(lFreq.med, getPosterior), title = 'Med')
plot.bar(sapply(lFreq.ran, getPosterior), title = 'Ran')

par(mfrow=c(1,1))

mDat.med = sapply(lFreq.med, getPosterior)
mDat.ran = sapply(lFreq.ran, getPosterior)
mPlot = lapply(1:4, function(x){
  cbind(mDat.med[,x], mDat.ran[,x])
})

mPlot = do.call(cbind, mPlot)

cn = sapply(1:4, function(x) c(colnames(mDat.med)[x], colnames(mDat.ran)[x]))
cn = as.vector(cn)
colnames(mPlot) = cn

plot.bar(mPlot, 'med vs background', col=grey.colors(2))
legend('topleft', legend = c('MeD', 'BG'), fill=grey.colors(2))

# scale each value by CA
mDat.med = sapply(lFreq.med, getPosterior)
mDat.ran = sapply(lFreq.ran, getPosterior)
mDat.bs = sapply(lFreq.bs, getPosterior)

mDat.med = sweep(mDat.med, 1, mDat.med[,'CA'], '/')
mDat.ran = sweep(mDat.ran, 1, mDat.ran[,'CA'], '/')
mDat.bs = sweep(mDat.bs, 1, mDat.bs[,'CA'], '/')

plot.bar(mDat.med, title = 'Scaled by CA - MedIP')
plot.bar(mDat.ran, title = 'Scaled by CA - BG')
plot.bar(mDat.bs, title = 'Scaled by CA - BS')

mPlot = lapply(1:4, function(x){
  cbind(mDat.med[,x], mDat.ran[,x], mDat.bs[,x])
})

mPlot = do.call(cbind, mPlot)

cn = sapply(1:4, function(x) c(colnames(mDat.med)[x], colnames(mDat.ran)[x], colnames(mDat.bs)[x]))
cn = as.vector(cn)
colnames(mPlot) = cn

plot.bar(mPlot, 'med vs background', col=grey.colors(3))
legend('topleft', legend = c('MeD', 'BG', 'BS'), fill=grey.colors(3))



