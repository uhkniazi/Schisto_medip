# File: 03_bis_seq_vs_medip.R
# Auth: u.niazi@imperial.ac.uk
# DESC: uses the data generated by frank lyko and analyzed by bismark - and compared with medip data
# Date: 27/05/2015


# source header file
source('00_header.R')


##################################################################
######## data loading and formatting
p = paste('Choose R object file with pooled Medip peaks, look in Objects/ directoy')
print(p)
oGRpooled = f_LoadObject(file.choose())

# keep only the medip peaks from class 'm' i.e. adult male
f = which(oGRpooled$groups.lab %in% c('m', 'sfm', 'sm', 'fm'))
oGRpooled = oGRpooled[f]
# 
# oGR.bis = read.csv(file.choose(), header=F, sep='\t')
# oGR.bis = oGR.bis[-1,]
# oGR.bis = GRanges(oGR.bis$V1, IRanges(oGR.bis$V2, oGR.bis$V3), mcols=DataFrame(proportion=oGR.bis$V4))

## load from here for next use or load the stranded object
oGR.bis = f_LoadObject(file.choose())

##############################################
### this section not needed if we load stranded object 
# # keep only the chromosomes of interest
# f = seqnames(oGRpooled) %in% gcvChromosomes[1]
# oGRpooled = oGRpooled[!f]
# 
# oGR.bis = oGR.bis[seqnames(oGR.bis) %in% gcvChromosomes]
# 
# ## assign strands to the base positions
# ## use the biostrings object for genome version 5.2 created earlier
# library(Biostrings)
# seq = f_LoadObject(file.choose())
# base = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis)
# f = base == 'C'
# st = rep(NA, length(f))
# st[f] = '+'
# st[!f] = '-'
# strand(oGR.bis) = st
###############################################

## remove chromosome zw
# remove chromosome ZW from the analysis due to conflicting assembly versions
f = seqnames(oGRpooled) %in% gcvChromosomes[1]
oGRpooled = oGRpooled[!f]

oGR.bis = oGR.bis[seqnames(oGR.bis) %in% gcvChromosomes]


########## remove Cs with 0 proportions
f = which(oGR.bis$mcols.proportion == 0)
oGR.bis = oGR.bis[-f]
gc()
# break the data into parts/groups based on quantiles
cut.pts = quantile(oGR.bis$mcols.proportion, probs = 0:10/10)
groups = cut(oGR.bis$mcols.proportion, breaks = cut.pts, include.lowest = T, labels = 1:10)
boxplot(oGR.bis$mcols.proportion ~ groups, las=2)
oGR.bis$groups = groups

############## load the features object for overlaps
p = paste('Choose features object created earlier with create_features_from_gff.R')
print(p)
lFeatures = f_LoadObject(file.choose())

## count over features granges 
lFeatures$gene = NULL
lFeatures$desc = NULL

############# look at overlaps of medip and bs-seq
### how many overlaps between bs-seq data and medip peaks in males
dfOverlaps = data.frame(table(overlapsAny(oGRpooled, oGR.bis)))
dfOverlaps.nostrand = data.frame(table(overlapsAny(oGRpooled, oGR.bis, ignore.strand=T)))

# do it the other way
dfOverlaps.bs = data.frame(table(overlapsAny(oGR.bis, oGRpooled)))
dfOverlaps.bs.nostrand = data.frame(table(overlapsAny(oGR.bis, oGRpooled, ignore.strand=T)))

### check overlaps based on groups
c = rep(NA, length=10)
for (i in 10:1){
  c[i] = sum(overlapsAny(oGRpooled, oGR.bis[as.numeric(oGR.bis$groups)  >= i]))
}
plot(c, type='b', main='MeDIP Overlap with BS-Seq', xlab='Groups', ylab='Overlaps', sub='As we move along the groups')
c.m = c/max(c)

# c = rep(NA, length=10)
# for (i in 10:1){
#   m = matrix(table(overlapsAny(oGR.bis[as.numeric(oGR.bis$groups)  >= i], oGRpooled)))
#   c[i] = m[2,]/colSums(m)
# }
# plot(c, type='b', main='BS-Seq Overlap with MeDIP', xlab='Groups', ylab='Overlaps', sub='As we move along the groups')
# c.b = c/max(c)
# 
# plot(c.m, type='b', main='Overlaps at different cutoffs for BS-Seq groups', 
#      xlab='Groups', ylab='Overlaps', sub='As we move along the groups')
# lines(c.b, type='b', col=2)
# legend('topright', legend = c('MeD v BS', 'BS v MeD'), fill = 1:2)

## plot the distribution over the features for MeDIP
lOverlaps = sapply(lFeatures, function(x) overlapsAny(x, oGRpooled))
mDat = sapply(lOverlaps, table)
rownames(mDat) = c('False', 'True')
# calculate confidence intervals/errors by simulating the data
ivProb.medip.all = mDat['True',] / rowSums(mDat)['True']
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mDat.medip.all = mDat['True',]
mSim.medip.all = t(rmultinom(n = 1000, size = 1000, prob = ivProb.medip.all))
# convert to probability scale for plotting
mSim.medip.all = mSim.medip.all / rowSums(mSim.medip.all)

## plot for BS-Seq
lOverlaps = sapply(lFeatures, function(x) overlapsAny(x, oGR.bis))
mDat = sapply(lOverlaps, table)
rownames(mDat) = c('False', 'True')
# calculate confidence intervals/errors by simulating the data
ivProb.bis.all = mDat['True',] / rowSums(mDat)['True']
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mDat.bis.all = mDat['True',]
mSim.bis.all = t(rmultinom(n = 1000, size = 1000, prob = ivProb.bis.all))
# convert to probability scale for plotting
mSim.bis.all = mSim.bis.all / rowSums(mSim.bis.all)

### plot the 2 data together
c = rainbow(2)
mBar = rbind(ivProb.medip.all, ivProb.bis.all)
rownames(mBar) = c('MeDIP', 'BS-Seq')
l2 = barplot(mBar, beside=T, ylim=c(0, 0.8), col=c, main='All MeDIP and BS-Seq data')
legend('topleft', legend = rownames(mBar), fill = c)
l = l2[1,]
## make error bars
m = apply(mSim.medip.all, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

l = l2[2,]
## make error bars
m = apply(mSim.bis.all, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

##################################################################################
## plots for comparing subgroups i.e. group 10
lOverlaps = sapply(lFeatures, function(x) overlapsAny(x, oGRpooled))
mDat = sapply(lOverlaps, table)
rownames(mDat) = c('False', 'True')
# calculate confidence intervals/errors by simulating the data
ivProb.medip.all = mDat['True',] / rowSums(mDat)['True']
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mDat.medip.all = mDat['True',]
mSim.medip.all = t(rmultinom(n = 1000, size = 1000, prob = ivProb.medip.all))
# convert to probability scale for plotting
mSim.medip.all = mSim.medip.all / rowSums(mSim.medip.all)

## plot for BS-Seq
lOverlaps = sapply(lFeatures, function(x) overlapsAny(x, oGR.bis[as.numeric(oGR.bis$groups) >= 10]))
mDat = sapply(lOverlaps, table)
rownames(mDat) = c('False', 'True')
# calculate confidence intervals/errors by simulating the data
ivProb.bis.all = mDat['True',] / rowSums(mDat)['True']
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mDat.bis.all = mDat['True',]
mSim.bis.all = t(rmultinom(n = 1000, size = 1000, prob = ivProb.bis.all))
# convert to probability scale for plotting
mSim.bis.all = mSim.bis.all / rowSums(mSim.bis.all)

### plot the 2 data together
c = rainbow(2)
mBar = rbind(ivProb.medip.all, ivProb.bis.all)
rownames(mBar) = c('MeDIP', 'BS-Seq')
l2 = barplot(mBar, beside=T, ylim=c(0, 0.8), col=c, main='All MeDIP and BS-Seq data Group 10')
legend('topleft', legend = rownames(mBar), fill = c)
l = l2[1,]
## make error bars
m = apply(mSim.medip.all, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

l = l2[2,]
## make error bars
m = apply(mSim.bis.all, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

##################################################################################
###### dinucleotide frequencies
library(Biostrings)
# load the biostrings sequence object
seq = f_LoadObject(file.choose())
# seq is a DNAStringSet object created sometime back from genome version 5.2
oGR.bis.w = resize(oGR.bis, 2, fix = 'start')
seq.bs.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '+'])
seq.bs.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '-'])
# sequence on minus strand reverse complimented
seq.bs.minus = reverseComplement(seq.bs.minus)
seq.bs = c(seq.bs.plus, seq.bs.minus)
mNucFreq.bis = dinucleotideFrequency(seq.bs, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
ivNucFreq.bis = colSums(mNucFreq.bis)

## calculate for medip data
## choose only peaks with a width upto the 3rd quantile
c = quantile(width(oGRpooled), prob=0.75)
f = which(width(oGRpooled) <= c)
oGRpooled.sub = oGRpooled[f]
# get the sequence for plus, * and minus sides
seq.med.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) != '-'])
seq.med.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) == '-'])
seq.med.minus = reverseComplement(seq.med.minus)
seq.med = c(seq.med.plus, seq.med.minus)
mNucFreq.med = dinucleotideFrequency(seq.med, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
ivNucFreq.med = colSums(mNucFreq.med)

#################################################################
## make plots of both frequencies
# calculate confidence intervals/errors by simulating the data
ivProb.medip.nuc = ivNucFreq.med / sum(ivNucFreq.med)
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mSim.medip.nuc = t(rmultinom(n = 1000, size = 1000, prob = ivProb.medip.nuc))
# convert to probability scale for plotting
mSim.medip.nuc = mSim.medip.nuc / rowSums(mSim.medip.nuc)

## plot for BS-Seq
# calculate confidence intervals/errors by simulating the data
ivProb.bis.nuc = ivNucFreq.bis / sum(ivNucFreq.bis)
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mSim.bis.nuc = t(rmultinom(n = 1000, size = 1000, prob = ivProb.bis.nuc))
# convert to probability scale for plotting
mSim.bis.nuc = mSim.bis.nuc / rowSums(mSim.bis.nuc)

### plot the 2 data together
c = rainbow(2)
mBar = rbind(ivProb.medip.nuc, ivProb.bis.nuc)
rownames(mBar) = c('MeDIP', 'BS-Seq')
l2 = barplot(mBar, beside=T, ylim=c(0, 0.5), col=c, main='Dinucleotide Frequencies')
legend('topright', legend = rownames(mBar), fill = c)
l = l2[1,]
## make error bars
m = apply(mSim.medip.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

l = l2[2,]
## make error bars
m = apply(mSim.bis.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

######################################################################
######################################################################
## Repeat this analysis for only peaks in group 10
oGR.bis.bk = oGR.bis
oGR.bis = oGR.bis[oGR.bis$groups == 10]
oGR.bis.w = resize(oGR.bis, 2, fix = 'start')
seq.bs.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '+'])
seq.bs.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '-'])
# sequence on minus strand reverse complimented
seq.bs.minus = reverseComplement(seq.bs.minus)
seq.bs = c(seq.bs.plus, seq.bs.minus)
mNucFreq.bis = dinucleotideFrequency(seq.bs, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
ivNucFreq.bis = colSums(mNucFreq.bis)

## calculate for medip data
## choose only peaks with a width upto the 3rd quantile
oGRpooled.bk = oGRpooled
oGRpooled = oGRpooled[overlapsAny(oGRpooled, oGR.bis)]
c = quantile(width(oGRpooled), prob=0.75)
f = which(width(oGRpooled) <= c)
oGRpooled.sub = oGRpooled[f]
# get the sequence for plus, * and minus sides
seq.med.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) != '-'])
seq.med.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) == '-'])
seq.med.minus = reverseComplement(seq.med.minus)
seq.med = c(seq.med.plus, seq.med.minus)
mNucFreq.med = dinucleotideFrequency(seq.med, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
ivNucFreq.med = colSums(mNucFreq.med)

#################################################################
## make plots of both frequencies
# calculate confidence intervals/errors by simulating the data
ivProb.medip.nuc = ivNucFreq.med / sum(ivNucFreq.med)
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mSim.medip.nuc = t(rmultinom(n = 1000, size = 1000, prob = ivProb.medip.nuc))
# convert to probability scale for plotting
mSim.medip.nuc = mSim.medip.nuc / rowSums(mSim.medip.nuc)

## plot for BS-Seq
# calculate confidence intervals/errors by simulating the data
ivProb.bis.nuc = ivNucFreq.bis / sum(ivNucFreq.bis)
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mSim.bis.nuc = t(rmultinom(n = 1000, size = 1000, prob = ivProb.bis.nuc))
# convert to probability scale for plotting
mSim.bis.nuc = mSim.bis.nuc / rowSums(mSim.bis.nuc)

### plot the 2 data together
c = rainbow(2)
mBar = rbind(ivProb.medip.nuc, ivProb.bis.nuc)
rownames(mBar) = c('MeDIP', 'BS-Seq')
l2 = barplot(mBar, beside=T, ylim=c(0, 0.5), col=c, main='Dinucleotide Frequencies: Only Group 10')
legend('topright', legend = rownames(mBar), fill = c)
l = l2[1,]
## make error bars
m = apply(mSim.medip.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

l = l2[2,]
## make error bars
m = apply(mSim.bis.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)


################################################################

# 
# 
# ### load the gene casette
# p = paste('Choose features casette created earlier with create_features_from_gff.R')
# print(p)
# lFeatures = f_LoadObject(file.choose())
# 
# ######################################################
# ### Analysis
# ### how many overlaps between bs-seq data and medip peaks in males
# dfOverlaps = data.frame(table(overlapsAny(oGRpooled, oGR.bis)))
# dfOverlaps.nostrand = data.frame(table(overlapsAny(oGRpooled, oGR.bis, ignore.strand=T)))
# 
# ### Gene Casette overlaps
# ## count for medip data
# # create a matrix to hold the matches
# mFeatures = matrix(NA, nrow = length(lFeatures$fst.exon), ncol = 5)
# colnames(mFeatures) = c('upstream', 'fst.exon', 'exons.others', 'introns', 'downstream')
# rownames(mFeatures) = names(lFeatures$fst.exon)
# cn = colnames(mFeatures)
# rn = rownames(mFeatures)
# # fill the data
# for(i in 1:ncol(mFeatures)){
#   # fill data one column at a time
#   mFeatures[,i] = overlapsAny(lFeatures[[cn[i]]][rn], oGRpooled, ignore.strand=F)
# }
# f = rowSums(mFeatures)
# # number of genes with a signal
# table(f > 0)
# mFeatures.medip = mFeatures
# # summarize the data
# mBar = colSums(mFeatures)
# print(mBar)
# mBar.medip = mBar
# 
# ## count for bs-seq data
# mFeatures = matrix(NA, nrow = length(lFeatures$fst.exon), ncol = 5)
# colnames(mFeatures) = c('upstream', 'fst.exon', 'exons.others', 'introns', 'downstream')
# rownames(mFeatures) = names(lFeatures$fst.exon)
# cn = colnames(mFeatures)
# rn = rownames(mFeatures)
# # fill the data
# for(i in 1:ncol(mFeatures)){
#   # fill data one column at a time
#   mFeatures[,i] = overlapsAny(lFeatures[[cn[i]]][rn], unique(oGR.bis), ignore.strand=F)
# }
# f = rowSums(mFeatures)
# # number of genes with a signal
# table(f > 0)
# mFeatures.bis = mFeatures
# # summarize the data
# mBar = colSums(mFeatures)
# print(mBar)
# mBar.bs = mBar
# 
# mBar = rbind(mBar.medip, mBar.bs)
# mBar.p = mBar / rowSums(mBar)
# c = rainbow(2)
# bar = barplot(mBar.p, beside=T, col=c, main='Distribution over the Gene Casette for BS-Seq and MeDIP Data',
#         ylim=c(0,0.8))
# legend('topright', legend = c('MeDIP', 'BS-Seq'), fill=c)
# 
# ## perform proportion tests on the data by modelling the distribution as binomial 
# ## where n = number of genes
# ## for each feature e.g. upstream
# ## success is number of TRUE and failures is FALSE
# ## Compare the proprtions of successes in the 2 cases i.e. medip vs bs
# p.val = rep(NA, length.out = ncol(mFeatures.bis))
# names(p.val) = colnames(mFeatures.bis)
# 
# for (i in 1:length(p.val)){
#   n = names(p.val)[i]
#   # calculate success for med and bis
#   trials = nrow(mFeatures.bis)
#   success.med = sum(mFeatures.medip[,n])
#   success.bis = sum(mFeatures.bis[,n])
#   p.val[i] = prop.test(c(success.med, success.bis), n = c(trials,trials))$p.value
# }
# 
# i = which(p.val < 0.01)
# # draw stars on significant values
# pos = colMeans(bar)[i]
# points(pos, rep(0.72, times=length(pos)), pch='*', cex=2)
# 
# # 
# # 
# # 
# # 
# # 
# # 
# # 
# # ## prop.test(c(170, 233), c(403,403))
# # chisq.test(mBar[1,], p = mBar.p[2,], simulate.p.value = T)

