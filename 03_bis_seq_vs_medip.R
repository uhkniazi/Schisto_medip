# File: 03_bis_seq_vs_medip.R
# Auth: u.niazi@imperial.ac.uk
# DESC: uses the data generated by frank lyko and analyzed by bismark - and compared with medip data
# Date: 27/05/2015


# source header file
source('00_header.R')
library(Biostrings)

##################################################################
######## data loading and formatting
p = paste('Choose R object file with pooled Medip peaks, look in Objects/ directoy')
print(p)
oGRpooled = f_LoadObject(file.choose())

# keep only the medip peaks from class 'm' i.e. adult male
f = which(oGRpooled$groups.lab %in% c('m', 'sfm', 'sm', 'fm'))
oGRpooled = oGRpooled[f]
oGRpooled = oGRpooled[seqnames(oGRpooled) %in% gcvChromosomes]
# 
# oGR.bis = read.csv(file.choose(), header=F, sep='\t')
# oGR.bis = oGR.bis[-1,]
# oGR.bis = GRanges(oGR.bis$V1, IRanges(oGR.bis$V2, oGR.bis$V3), mcols=DataFrame(proportion=oGR.bis$V4))

## load from here for next use or load the unstranded object
oGR.bis = f_LoadObject(file.choose())
########## remove Cs with 0.1 or less proportions
f = which(oGR.bis$mcols.proportion >= 0.1)
## create a histogram of the data based on proportions similar to lyko paper figure 1
x = oGR.bis$mcols.proportion[f]
s = seq(0.1, to = 1, by = 0.1)
hist(x, breaks=s, ylab='Frequency', xlab='Proportion', main='Methylation proportions of 5mCs', xaxt='n')
axis(1, at = s)

f = which(oGR.bis$mcols.proportion >= 0.9)
oGR.bis = oGR.bis[f]
gc()
## assign strands to the base positions
## use the biostrings object for genome version 5.2 created earlier
seq = f_LoadObject(file.choose())
# rename all the W chromosome to ZW
r1 = oGR.bis[seqnames(oGR.bis) %in% gcvChromosomes]
r2 = oGR.bis[seqnames(oGR.bis) == 'Schisto_mansoni.Chr_W']
r1 = GRanges(as.character(seqnames(r1)), IRanges(start(r1), end(r1)), strand(r1), DataFrame(mcols(r1)))
r2 = GRanges('Schisto_mansoni.Chr_ZW', IRanges(start(r2), end(r2)), strand(r2), DataFrame(mcols(r2)))
oGR.bis = c(r1, r2)
s = unique(seqnames(oGR.bis))
for (i in 1:length(s)){
  # check base content for the chromosome
  base = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis[seqnames(oGR.bis) == s[i]])
  print(s[i])
  print(colSums(alphabetFrequency(base)))
  # remove bases with A or T as those are not the right positions
  f = base == 'C'
  st = rep(NA, length(f))
  st[f] = '+'
  st[!f] = '-'
  f2 = which(seqnames(oGR.bis) == s[i])
  strand(oGR.bis[f2]) = st
}
rm(list = c('base', 'f', 'f2', 'r1', 'r2', 'st'))
gc()

# break the bs-seq data into parts/groups based on quantiles
# cut.pts = quantile(oGR.bis$mcols.proportion, probs = 0:10/10)
# groups = cut(oGR.bis$mcols.proportion, breaks = cut.pts, include.lowest = T, labels = 1:10)
# boxplot(oGR.bis$mcols.proportion ~ groups, las=2)
# oGR.bis$groups = groups

############## load the features object for overlaps
p = paste('Choose features object created earlier with create_features_from_gff.R')
print(p)
lFeatures = f_LoadObject(file.choose())

## count over features granges 
lFeatures$gene = NULL
lFeatures$desc = NULL

############# look at overlaps of medip and bs-seq
### how many overlaps between bs-seq data and medip peaks in males
dfOverlaps = data.frame(table(overlapsAny(oGRpooled, oGR.bis)))
dfOverlaps.nostrand = data.frame(table(overlapsAny(oGRpooled, oGR.bis, ignore.strand=T)))

# do it the other way
dfOverlaps.bs = data.frame(table(overlapsAny(oGR.bis, oGRpooled)))
dfOverlaps.bs.nostrand = data.frame(table(overlapsAny(oGR.bis, oGRpooled, ignore.strand=T)))

### check overlaps based on groups
# c = rep(NA, length=10)
# for (i in 10:1){
#   c[i] = sum(overlapsAny(oGRpooled, oGR.bis[as.numeric(oGR.bis$groups)  >= i]))
# }
# plot(c, type='b', main='MeDIP Overlap with BS-Seq', xlab='Groups', ylab='Overlaps', sub='As we move along the groups')
# c.m = c/max(c)

# c = rep(NA, length=10)
# for (i in 10:1){
#   m = matrix(table(overlapsAny(oGR.bis[as.numeric(oGR.bis$groups)  >= i], oGRpooled)))
#   c[i] = m[2,]/colSums(m)
# }
# plot(c, type='b', main='BS-Seq Overlap with MeDIP', xlab='Groups', ylab='Overlaps', sub='As we move along the groups')
# c.b = c/max(c)
# 
# plot(c.m, type='b', main='Overlaps at different cutoffs for BS-Seq groups', 
#      xlab='Groups', ylab='Overlaps', sub='As we move along the groups')
# lines(c.b, type='b', col=2)
# legend('topright', legend = c('MeD v BS', 'BS v MeD'), fill = 1:2)

## plot the distribution over the features for MeDIP
lOverlaps = sapply(lFeatures, function(x) overlapsAny(x, oGRpooled))
mDat = sapply(lOverlaps, table)
rownames(mDat) = c('False', 'True')
# calculate confidence intervals/errors by simulating the data
ivProb.medip.all = mDat['True',] / rowSums(mDat)['True']
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mDat.medip.all = mDat['True',]
mSim.medip.all = t(rmultinom(n = 1000, size = 1000, prob = ivProb.medip.all))
# convert to probability scale for plotting
mSim.medip.all = mSim.medip.all / rowSums(mSim.medip.all)

## plot for BS-Seq
lOverlaps = sapply(lFeatures, function(x) overlapsAny(x, oGR.bis))
mDat = sapply(lOverlaps, table)
rownames(mDat) = c('False', 'True')
# calculate confidence intervals/errors by simulating the data
ivProb.bis.all = mDat['True',] / rowSums(mDat)['True']
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mDat.bis.all = mDat['True',]
mSim.bis.all = t(rmultinom(n = 1000, size = 1000, prob = ivProb.bis.all))
# convert to probability scale for plotting
mSim.bis.all = mSim.bis.all / rowSums(mSim.bis.all)

# plot for BS-Seq
c = 'pink'
mBar = rbind(ivProb.bis.all)
rownames(mBar) = c('BS-Seq')
l = barplot(mBar, beside=T, ylim=c(0, 0.8), col=c, main='BS-Seq data at 0.9 cutoff', ylab='fraction')
## make error bars
m = apply(mSim.bis.all, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

### plot the 2 data together
c = rainbow(2)
mBar = rbind(ivProb.medip.all, ivProb.bis.all)
rownames(mBar) = c('MeDIP', 'BS-Seq')
l2 = barplot(mBar, beside=T, ylim=c(0, 0.8), col=c, main='All MeDIP and BS-Seq data', ylab='fraction')
legend('topleft', legend = rownames(mBar), fill = c)
l = l2[1,]
## make error bars
m = apply(mSim.medip.all, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

l = l2[2,]
## make error bars
m = apply(mSim.bis.all, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

##################################################################################
## plots for comparing subgroups i.e. group 10
# lOverlaps = sapply(lFeatures, function(x) overlapsAny(x, oGRpooled))
# mDat = sapply(lOverlaps, table)
# rownames(mDat) = c('False', 'True')
# # calculate confidence intervals/errors by simulating the data
# ivProb.medip.all = mDat['True',] / rowSums(mDat)['True']
# # simulate data as a sample from a multinomial distribution
# # P(y | Theta)
# mDat.medip.all = mDat['True',]
# mSim.medip.all = t(rmultinom(n = 1000, size = 1000, prob = ivProb.medip.all))
# # convert to probability scale for plotting
# mSim.medip.all = mSim.medip.all / rowSums(mSim.medip.all)
# 
# ## plot for BS-Seq
# lOverlaps = sapply(lFeatures, function(x) overlapsAny(x, oGR.bis[as.numeric(oGR.bis$groups) >= 10]))
# mDat = sapply(lOverlaps, table)
# rownames(mDat) = c('False', 'True')
# # calculate confidence intervals/errors by simulating the data
# ivProb.bis.all = mDat['True',] / rowSums(mDat)['True']
# # simulate data as a sample from a multinomial distribution
# # P(y | Theta)
# mDat.bis.all = mDat['True',]
# mSim.bis.all = t(rmultinom(n = 1000, size = 1000, prob = ivProb.bis.all))
# # convert to probability scale for plotting
# mSim.bis.all = mSim.bis.all / rowSums(mSim.bis.all)
# 
# ### plot the 2 data together
# c = rainbow(2)
# mBar = rbind(ivProb.medip.all, ivProb.bis.all)
# rownames(mBar) = c('MeDIP', 'BS-Seq')
# l2 = barplot(mBar, beside=T, ylim=c(0, 0.8), col=c, main='All MeDIP and BS-Seq data Group 10')
# legend('topleft', legend = rownames(mBar), fill = c)
# l = l2[1,]
# ## make error bars
# m = apply(mSim.medip.all, 2, function(x) quantile(x, c(0.025, 0.975)))
# segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
# segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
# segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)
# 
# l = l2[2,]
# ## make error bars
# m = apply(mSim.bis.all, 2, function(x) quantile(x, c(0.025, 0.975)))
# segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
# segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
# segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

##################################################################################
###### dinucleotide frequencies
# seq is a DNAStringSet object created sometime back from genome version 5.2
oGR.bis.w = resize(oGR.bis, 2, fix = 'start')
s = unique(seqnames(oGR.bis.w))
m = matrix(NA, nrow = length(s), ncol = 4)

for (i in 1:length(s)){
  # check base content for the chromosome
  seq.bs.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '+' & seqnames(oGR.bis.w) == s[i]])
  seq.bs.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '-' & seqnames(oGR.bis.w) == s[i]])
  print(s[i])
  seq.bs.minus = reverseComplement(seq.bs.minus)
  seq.bs = c(seq.bs.plus, seq.bs.minus)
  print(colSums(dinucleotideFrequency(seq.bs)))
  mNucFreq.bis = dinucleotideFrequency(seq.bs, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
  ivNucFreq.bis = colSums(mNucFreq.bis)
  m[i,] = ivNucFreq.bis
}
# 
# seq.bs.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '+'])
# seq.bs.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '-'])
# # sequence on minus strand reverse complimented
# seq.bs.minus = reverseComplement(seq.bs.minus)
# seq.bs = c(seq.bs.plus, seq.bs.minus)
# mNucFreq.bis = dinucleotideFrequency(seq.bs, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
# ivNucFreq.bis = colSums(mNucFreq.bis)
ivNucFreq.bis = colSums(m)
names(ivNucFreq.bis) = c('CA', 'CC', 'CG', 'CT')
rm(list = c('m', 'seq.bs.plus', 'seq.bs.minus', 'seq.bs', 'mNucFreq.bis', 'oGR.bis.w'))
## calculate for medip data
## choose only peaks with a width upto the 0.95 quantile
c = quantile(width(oGRpooled), prob=0.95)
f = which(width(oGRpooled) <= c)
oGRpooled.sub = oGRpooled[f]
# get the sequence for plus, * and minus sides
s = unique(seqnames(oGRpooled.sub))
m = matrix(NA, nrow = length(s), ncol = 4)

for (i in 1:length(s)){
  # check base content for the chromosome
  seq.med.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) == '+' & seqnames(oGRpooled.sub) == s[i]])
  seq.med.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) == '-' & seqnames(oGRpooled.sub) == s[i]])
  print(s[i])
  seq.med.minus = reverseComplement(seq.med.minus)
  seq.med = c(seq.med.plus, seq.med.minus)
  print(colSums(dinucleotideFrequency(seq.med)))
  mNucFreq.med = dinucleotideFrequency(seq.med, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
  ivNucFreq.med = colSums(mNucFreq.med)
  m[i,] = ivNucFreq.med
}

# seq.med.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) != '-'])
# seq.med.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) == '-'])
# seq.med.minus = reverseComplement(seq.med.minus)
# seq.med = c(seq.med.plus, seq.med.minus)
# mNucFreq.med = dinucleotideFrequency(seq.med, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
# ivNucFreq.med = colSums(mNucFreq.med)
ivNucFreq.med = colSums(m)
names(ivNucFreq.med) = c('CA', 'CC', 'CG', 'CT')
rm(list = c('m', 'seq.med.plus', 'seq.med.minus', 'seq.med', 'mNucFreq.med', 'oGRpooled.sub'))

#################################################################
## make plots of both frequencies
# calculate confidence intervals/errors by simulating the data
ivProb.medip.nuc = ivNucFreq.med / sum(ivNucFreq.med)
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mSim.medip.nuc = t(rmultinom(n = 1000, size = 1000, prob = ivProb.medip.nuc))
# convert to probability scale for plotting
mSim.medip.nuc = mSim.medip.nuc / rowSums(mSim.medip.nuc)

## plot for BS-Seq
# calculate confidence intervals/errors by simulating the data
ivProb.bis.nuc = ivNucFreq.bis / sum(ivNucFreq.bis)
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mSim.bis.nuc = t(rmultinom(n = 1000, size = 1000, prob = ivProb.bis.nuc))
# convert to probability scale for plotting
mSim.bis.nuc = mSim.bis.nuc / rowSums(mSim.bis.nuc)

### plot the bs-seq data separately
l = barplot(ivProb.bis.nuc, beside=T, ylim=c(0, 0.5), col='pink', main='Dinucleotide Frequencies BS-Seq', 
            sub='Proportion >= 0.1', ylab='fraction')
## make error bars
m = apply(mSim.bis.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)


### plot the 2 data together
c = rainbow(2)
mBar = rbind(ivProb.medip.nuc, ivProb.bis.nuc)
rownames(mBar) = c('MeDIP', 'BS-Seq')
l2 = barplot(mBar, beside=T, ylim=c(0, 0.5), col=c, main='Dinucleotide Frequencies', ylab='fraction')
legend('topright', legend = rownames(mBar), fill = c)
l = l2[1,]
## make error bars
m = apply(mSim.medip.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

l = l2[2,]
## make error bars
m = apply(mSim.bis.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

#####################################################################
#### take a random sample from chromosome 1 and plot together
s = seq[gcvChromosomes[2]]
r = f_bin_vector(1, end = 65476681, bins = 130953)
i = sample(1:nrow(r), size = 20000, replace = F)
r = r[i,]
# ranges of 500 size
ran = GRanges(gcvChromosomes[2], IRanges(r$start, r$end))
s = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, ran)
ran.f = dinucleotideFrequency(s, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
ran.f = colSums(ran.f)

ivProb.ran.nuc = ran.f / sum(ran.f)
# simulate data as a sample from a multinomial distribution
# P(y | Theta)
mSim.ran.nuc = t(rmultinom(n = 1000, size = 1000, prob = ivProb.ran.nuc))
# convert to probability scale for plotting
mSim.ran.nuc = mSim.ran.nuc / rowSums(mSim.ran.nuc)

## plot the 3 sets together
c = rainbow(3)
mBar = rbind(ivProb.medip.nuc, ivProb.bis.nuc, ivProb.ran.nuc)
rownames(mBar) = c('MeDIP', 'BS-Seq', 'Background')
l2 = barplot(mBar, beside=T, ylim=c(0, 0.5), col=c, main='Dinucleotide Frequencies', ylab='fraction')
legend('topright', legend = rownames(mBar), fill = c)
l = l2[1,]
## make error bars
m = apply(mSim.medip.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

l = l2[2,]
## make error bars
m = apply(mSim.bis.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)

l = l2[3,]
## make error bars
m = apply(mSim.ran.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)


######################################################################
### breakdown of repeats into subclasses
#######################
## function to simulate
f_sim_multi = function(prob){
  m = t(rmultinom(n = 1000, size = 1000, prob = prob))
  # convert to probability scale for plotting
  return(m/rowSums(m))
}

f_sim_ci = function(prob){
  m = f_sim_multi(prob)
  return(apply(m, 2, function(x) quantile(x, c(0.025, 0.975))))
}
#######################
# load the repeats object 
oGRrep = f_LoadObject(file.choose())

# rename all the W chromosome to ZW
r1 = oGRrep[seqnames(oGRrep) %in% gcvChromosomes]
r2 = oGRrep[seqnames(oGRrep) == 'Schisto_mansoni.Chr_W']
r1 = GRanges(as.character(seqnames(r1)), IRanges(start(r1), end(r1)), strand(r1), DataFrame(mcols(r1)))
r2 = GRanges('Schisto_mansoni.Chr_ZW', IRanges(start(r2), end(r2)), strand(r2), DataFrame(mcols(r2)))
oGRrep = c(r1, r2)

#oGRrep = oGRrep[seqnames(oGRrep) %in% gcvChromosomes]

f = oGRrep$mcols.class
oGRLrep = split(oGRrep, f)
# count overlaps
mMed = sapply(oGRLrep, function(x) factor(overlapsAny(x, oGRpooled),levels = c('TRUE', 'FALSE')))
mMed = sapply(mMed, table)

mBis = sapply(oGRLrep, function(x) factor(overlapsAny(x, oGR.bis),levels = c('TRUE', 'FALSE')))
mBis = sapply(mBis, table)

mRan = sapply(oGRLrep, function(x) factor(overlapsAny(x, ran),levels = c('TRUE', 'FALSE')))
mRan = sapply(mRan, table)

## plot the results
ivMed = mMed['TRUE',] / rowSums(mMed)['TRUE']
ivBis = mBis['TRUE',] / rowSums(mBis)['TRUE']
ivRan = mRan['TRUE',] / rowSums(mRan)['TRUE']

mBar = rbind(ivMed, ivBis, ivRan)
rownames(mBar) = c('MeDIP', 'BS-Seq', 'Background')
c = rainbow(3)

l2 = barplot(mBar, beside=T, las=2, main='Distribution over Repeats', col=c, ylim=c(0, 0.6), sub='BS-Seq cutoff >= 0.9',
             ylab='fraction')
legend('topright', legend = rownames(mBar), fill=c)

# draw error bars
for (i in 1:nrow(mBar)){
  l = l2[i,]
  ## make error bars
  m = f_sim_ci(mBar[i,])
  segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
  segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
  segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)
}

# ######################################################################
# ## Repeat this analysis for only peaks in group 10
# oGR.bis.bk = oGR.bis
# oGR.bis = oGR.bis[oGR.bis$groups == 10]
# oGR.bis.w = resize(oGR.bis, 2, fix = 'start')
# seq.bs.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '+'])
# seq.bs.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGR.bis.w[strand(oGR.bis.w) == '-'])
# # sequence on minus strand reverse complimented
# seq.bs.minus = reverseComplement(seq.bs.minus)
# seq.bs = c(seq.bs.plus, seq.bs.minus)
# mNucFreq.bis = dinucleotideFrequency(seq.bs, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
# ivNucFreq.bis = colSums(mNucFreq.bis)
# 
# ## calculate for medip data
# ## choose only peaks with a width upto the 3rd quantile
# oGRpooled.bk = oGRpooled
# oGRpooled = oGRpooled[overlapsAny(oGRpooled, oGR.bis)]
# c = quantile(width(oGRpooled), prob=0.75)
# f = which(width(oGRpooled) <= c)
# oGRpooled.sub = oGRpooled[f]
# # get the sequence for plus, * and minus sides
# seq.med.plus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) != '-'])
# seq.med.minus = f_DNAStringSet_GRangesSequenceFromDNAStringSet(seq, oGRpooled.sub[strand(oGRpooled.sub) == '-'])
# seq.med.minus = reverseComplement(seq.med.minus)
# seq.med = c(seq.med.plus, seq.med.minus)
# mNucFreq.med = dinucleotideFrequency(seq.med, as.prob=F)[,c('CA', 'CC', 'CG', 'CT')]
# ivNucFreq.med = colSums(mNucFreq.med)
# 
# #################################################################
# ## make plots of both frequencies
# # calculate confidence intervals/errors by simulating the data
# ivProb.medip.nuc = ivNucFreq.med / sum(ivNucFreq.med)
# # simulate data as a sample from a multinomial distribution
# # P(y | Theta)
# mSim.medip.nuc = t(rmultinom(n = 1000, size = 1000, prob = ivProb.medip.nuc))
# # convert to probability scale for plotting
# mSim.medip.nuc = mSim.medip.nuc / rowSums(mSim.medip.nuc)
# 
# ## plot for BS-Seq
# # calculate confidence intervals/errors by simulating the data
# ivProb.bis.nuc = ivNucFreq.bis / sum(ivNucFreq.bis)
# # simulate data as a sample from a multinomial distribution
# # P(y | Theta)
# mSim.bis.nuc = t(rmultinom(n = 1000, size = 1000, prob = ivProb.bis.nuc))
# # convert to probability scale for plotting
# mSim.bis.nuc = mSim.bis.nuc / rowSums(mSim.bis.nuc)
# 
# ### plot the 2 data together
# c = rainbow(2)
# mBar = rbind(ivProb.medip.nuc, ivProb.bis.nuc)
# rownames(mBar) = c('MeDIP', 'BS-Seq')
# l2 = barplot(mBar, beside=T, ylim=c(0, 0.5), col=c, main='Dinucleotide Frequencies: Only Group 10')
# legend('topright', legend = rownames(mBar), fill = c)
# l = l2[1,]
# ## make error bars
# m = apply(mSim.medip.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
# segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
# segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
# segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)
# 
# l = l2[2,]
# ## make error bars
# m = apply(mSim.bis.nuc, 2, function(x) quantile(x, c(0.025, 0.975)))
# segments(l, y0 = m[1,], l, y1 = m[2,], lwd=2)
# segments(l-0.1, y0 = m[1,], l+0.1, y1 = m[1,], lwd=2)
# segments(l-0.1, y0 = m[2,], l+0.1, y1 = m[2,], lwd=2)
# 
# 
# ################################################################

# 
# 
# ### load the gene casette
# p = paste('Choose features casette created earlier with create_features_from_gff.R')
# print(p)
# lFeatures = f_LoadObject(file.choose())
# 
# ######################################################
# ### Analysis
# ### how many overlaps between bs-seq data and medip peaks in males
# dfOverlaps = data.frame(table(overlapsAny(oGRpooled, oGR.bis)))
# dfOverlaps.nostrand = data.frame(table(overlapsAny(oGRpooled, oGR.bis, ignore.strand=T)))
# 
# ### Gene Casette overlaps
# ## count for medip data
# # create a matrix to hold the matches
# mFeatures = matrix(NA, nrow = length(lFeatures$fst.exon), ncol = 5)
# colnames(mFeatures) = c('upstream', 'fst.exon', 'exons.others', 'introns', 'downstream')
# rownames(mFeatures) = names(lFeatures$fst.exon)
# cn = colnames(mFeatures)
# rn = rownames(mFeatures)
# # fill the data
# for(i in 1:ncol(mFeatures)){
#   # fill data one column at a time
#   mFeatures[,i] = overlapsAny(lFeatures[[cn[i]]][rn], oGRpooled, ignore.strand=F)
# }
# f = rowSums(mFeatures)
# # number of genes with a signal
# table(f > 0)
# mFeatures.medip = mFeatures
# # summarize the data
# mBar = colSums(mFeatures)
# print(mBar)
# mBar.medip = mBar
# 
# ## count for bs-seq data
# mFeatures = matrix(NA, nrow = length(lFeatures$fst.exon), ncol = 5)
# colnames(mFeatures) = c('upstream', 'fst.exon', 'exons.others', 'introns', 'downstream')
# rownames(mFeatures) = names(lFeatures$fst.exon)
# cn = colnames(mFeatures)
# rn = rownames(mFeatures)
# # fill the data
# for(i in 1:ncol(mFeatures)){
#   # fill data one column at a time
#   mFeatures[,i] = overlapsAny(lFeatures[[cn[i]]][rn], unique(oGR.bis), ignore.strand=F)
# }
# f = rowSums(mFeatures)
# # number of genes with a signal
# table(f > 0)
# mFeatures.bis = mFeatures
# # summarize the data
# mBar = colSums(mFeatures)
# print(mBar)
# mBar.bs = mBar
# 
# mBar = rbind(mBar.medip, mBar.bs)
# mBar.p = mBar / rowSums(mBar)
# c = rainbow(2)
# bar = barplot(mBar.p, beside=T, col=c, main='Distribution over the Gene Casette for BS-Seq and MeDIP Data',
#         ylim=c(0,0.8))
# legend('topright', legend = c('MeDIP', 'BS-Seq'), fill=c)
# 
# ## perform proportion tests on the data by modelling the distribution as binomial 
# ## where n = number of genes
# ## for each feature e.g. upstream
# ## success is number of TRUE and failures is FALSE
# ## Compare the proprtions of successes in the 2 cases i.e. medip vs bs
# p.val = rep(NA, length.out = ncol(mFeatures.bis))
# names(p.val) = colnames(mFeatures.bis)
# 
# for (i in 1:length(p.val)){
#   n = names(p.val)[i]
#   # calculate success for med and bis
#   trials = nrow(mFeatures.bis)
#   success.med = sum(mFeatures.medip[,n])
#   success.bis = sum(mFeatures.bis[,n])
#   p.val[i] = prop.test(c(success.med, success.bis), n = c(trials,trials))$p.value
# }
# 
# i = which(p.val < 0.01)
# # draw stars on significant values
# pos = colMeans(bar)[i]
# points(pos, rep(0.72, times=length(pos)), pch='*', cex=2)
# 
# # 
# # 
# # 
# # 
# # 
# # 
# # 
# # ## prop.test(c(170, 233), c(403,403))
# # chisq.test(mBar[1,], p = mBar.p[2,], simulate.p.value = T)

