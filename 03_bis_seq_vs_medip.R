# File: 03_bis_seq_vs_medip.R
# Auth: u.niazi@imperial.ac.uk
# DESC: uses the data generated by frank lyko and analyzed by bismark - and compared with medip data
# Date: 27/05/2015


# source header file
source('00_header.R')


##################################################################
######## data loading and formatting
p = paste('Choose R object file with pooled Medip peaks, look in Objects/ directoy')
print(p)
oGRpooled = f_LoadObject(file.choose())

# keep only the medip peaks from class 'm' i.e. adult male
f = which(oGRpooled$groups.lab %in% c('m', 'sfm', 'sm', 'fm'))
oGRpooled = oGRpooled[f]

## choose the correct bismark methyl extractor files
# read the Original Top (OT) file first
f = file.choose()
f2 = file.choose()
oGR.chh.ot = f_oGRReadBismarkMethylExtractor(file = f, '+')
oGR.chh.ob = f_oGRReadBismarkMethylExtractor(file = f2, '-')
f = file.choose()
f2 = file.choose()
oGR.chg.ot = f_oGRReadBismarkMethylExtractor(file = f, '+')
oGR.chg.ob = f_oGRReadBismarkMethylExtractor(file = f2, '-')
f = file.choose()
f2 = file.choose()
oGR.cg.ot = f_oGRReadBismarkMethylExtractor(file = f, '+')
oGR.cg.ob = f_oGRReadBismarkMethylExtractor(file = f2, '-')
# this may give a warning which we can ignore
oGR.bis = c(oGR.cg.ob, oGR.cg.ot, oGR.chg.ob, oGR.chg.ot, oGR.chh.ob, oGR.chh.ot)
oGR.bis = sort(oGR.bis)

# save object and load from here in future
save(oGR.bis, file='Objects/oGR.bis')

## if we want to remove low count potentially noisy data
## model the distribution of the data to see how many times
## a particular C is methylated and if it appears to follow a poisson
## or negative binomial distribution, then use that to remove noisy bits
# choose a cutoff by modelling the distribution shape
w = countOverlaps(unique(oGR.bis), oGR.bis)
w2 = log(w)
r = range(w2)
s = seq(floor(r[1])-0.5, ceiling(r[2])+0.5, by = 1)
r[1] = floor(r[1])
r[2] = ceiling(r[2])
hist(w2, prob=T, breaks=s, main='distribution of 5mCs over nucleotide positions', 
     xlab='log of counts', ylab='')
r = round(r)
dp = dpois(r[1]:r[2], lambda = median(w2))
dn = dnbinom(r[1]:r[2], size = median(w2), mu = median(w2))
lines(r[1]:r[2], dp, col='red', type='b')
lines(r[1]:r[2], dn, col='blue', type='b')
legend('topright', legend = c('poi', 'nbin'), fill = c('red', 'blue'))
c = qpois(0.05, median(w2), lower.tail = F)
points(c, 0, pch=20, col='red')
## we decide to use a poisson distribution
oGR.cg.ob = f_oGRRemovePoissonNoiseFromBismark(oGR.cg.ob)
oGR.cg.ot = f_oGRRemovePoissonNoiseFromBismark(oGR.cg.ot)
oGR.chg.ob = f_oGRRemovePoissonNoiseFromBismark(oGR.chg.ob)
oGR.chg.ot = f_oGRRemovePoissonNoiseFromBismark(oGR.chg.ot)
oGR.chh.ob = f_oGRRemovePoissonNoiseFromBismark(oGR.chh.ob)
oGR.chh.ot = f_oGRRemovePoissonNoiseFromBismark(oGR.chh.ot)
oGR.bis = c(oGR.cg.ob, oGR.cg.ot, oGR.chg.ob, oGR.chg.ot, oGR.chh.ob, oGR.chh.ot)
oGR.bis = sort(oGR.bis)
gc()


# remove chromosome ZW from the analysis due to conflicting assembly versions
f = seqnames(oGRpooled) %in% gcvChromosomes[1]
oGRpooled = oGRpooled[!f]

oGR.bis = oGR.bis[seqnames(oGR.bis) %in% gcvChromosomes]

### load the gene casette
p = paste('Choose features casette created earlier with create_features_from_gff.R')
print(p)
lFeatures = f_LoadObject(file.choose())

######################################################
### Analysis
### how many overlaps between bs-seq data and medip peaks in males
dfOverlaps = data.frame(table(overlapsAny(oGRpooled, oGR.bis)))
dfOverlaps.nostrand = data.frame(table(overlapsAny(oGRpooled, oGR.bis, ignore.strand=T)))

### Gene Casette overlaps
## count for medip data
# create a matrix to hold the matches
mFeatures = matrix(NA, nrow = length(lFeatures$fst.exon), ncol = 5)
colnames(mFeatures) = c('upstream', 'fst.exon', 'exons.others', 'introns', 'downstream')
rownames(mFeatures) = names(lFeatures$fst.exon)
cn = colnames(mFeatures)
rn = rownames(mFeatures)
# fill the data
for(i in 1:ncol(mFeatures)){
  # fill data one column at a time
  mFeatures[,i] = overlapsAny(lFeatures[[cn[i]]][rn], oGRpooled, ignore.strand=F)
}
f = rowSums(mFeatures)
# number of genes with a signal
table(f > 0)
mFeatures.medip = mFeatures
# summarize the data
mBar = colSums(mFeatures)
print(mBar)
mBar.medip = mBar

## count for bs-seq data
mFeatures = matrix(NA, nrow = length(lFeatures$fst.exon), ncol = 5)
colnames(mFeatures) = c('upstream', 'fst.exon', 'exons.others', 'introns', 'downstream')
rownames(mFeatures) = names(lFeatures$fst.exon)
cn = colnames(mFeatures)
rn = rownames(mFeatures)
# fill the data
for(i in 1:ncol(mFeatures)){
  # fill data one column at a time
  mFeatures[,i] = overlapsAny(lFeatures[[cn[i]]][rn], unique(oGR.bis), ignore.strand=F)
}
f = rowSums(mFeatures)
# number of genes with a signal
table(f > 0)
mFeatures.bis = mFeatures
# summarize the data
mBar = colSums(mFeatures)
print(mBar)
mBar.bs = mBar

mBar = rbind(mBar.medip, mBar.bs)
mBar.p = mBar / rowSums(mBar)
c = rainbow(2)
bar = barplot(mBar.p, beside=T, col=c, main='Distribution over the Gene Casette for BS-Seq and MeDIP Data',
        ylim=c(0,0.8))
legend('topright', legend = c('MeDIP', 'BS-Seq'), fill=c)

## perform proportion tests on the data by modelling the distribution as binomial 
## where n = number of genes
## for each feature e.g. upstream
## success is number of TRUE and failures is FALSE
## Compare the proprtions of successes in the 2 cases i.e. medip vs bs
p.val = rep(NA, length.out = ncol(mFeatures.bis))
names(p.val) = colnames(mFeatures.bis)

for (i in 1:length(p.val)){
  n = names(p.val)[i]
  # calculate success for med and bis
  trials = nrow(mFeatures.bis)
  success.med = sum(mFeatures.medip[,n])
  success.bis = sum(mFeatures.bis[,n])
  p.val[i] = prop.test(c(success.med, success.bis), n = c(trials,trials))$p.value
}

i = which(p.val < 0.01)
# draw stars on significant values
pos = colMeans(bar)[i]
points(pos, rep(0.72, times=length(pos)), pch='*', cex=2)

# 
# 
# 
# 
# 
# 
# 
# ## prop.test(c(170, 233), c(403,403))
# chisq.test(mBar[1,], p = mBar.p[2,], simulate.p.value = T)

